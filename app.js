class VideoGallery {
    constructor() {
        this.videos = [];
        this.isLoopEnabled = true;
        this.isMuted = false;
        this.init();
    }

    async init() {
        this.bindEvents();
        await this.loadVideos();
    }

    bindEvents() {
        // Control buttons
        document.getElementById('playAll').addEventListener('click', () => this.playAllVideos());
        document.getElementById('pauseAll').addEventListener('click', () => this.pauseAllVideos());
        document.getElementById('toggleLoop').addEventListener('click', () => this.toggleLoop());
        document.getElementById('toggleMute').addEventListener('click', () => this.toggleMute());
    }

    async loadVideos() {
        const videoGrid = document.getElementById('videoGrid');
        videoGrid.innerHTML = '<div class="loading">üîÑ Loading videos...</div>';

        try {
            // Try to load videos.json first (generated by sync script)
            const response = await fetch('/videos.json');
            if (response.ok) {
                const videoData = await response.json();
                this.renderVideos(videoData.videos || []);
            } else {
                // Fallback: try to discover videos in the /videos folder
                await this.discoverVideos();
            }
        } catch (error) {
            console.error('Error loading videos:', error);
            await this.discoverVideos();
        }
    }

    async discoverVideos() {
        // This is a fallback method that tries common video names
        // In production, this would be replaced by the videos.json approach
        const commonVideoNames = [
            'video1.mp4', 'video2.mp4', 'video3.mp4',
            'sample.mp4', 'demo.mp4', 'test.mp4'
        ];

        const availableVideos = [];
        
        for (const videoName of commonVideoNames) {
            try {
                const response = await fetch(`/videos/${videoName}`, { method: 'HEAD' });
                if (response.ok) {
                    availableVideos.push({
                        name: videoName,
                        path: `/videos/${videoName}`,
                        size: response.headers.get('content-length') || 'Unknown'
                    });
                }
            } catch (error) {
                // Video doesn't exist, continue
            }
        }

        if (availableVideos.length === 0) {
            this.renderNoVideos();
        } else {
            this.renderVideos(availableVideos);
        }
    }

    renderVideos(videos) {
        const videoGrid = document.getElementById('videoGrid');
        
        if (videos.length === 0) {
            this.renderNoVideos();
            return;
        }

        videoGrid.innerHTML = '';
        this.videos = videos;

        videos.forEach((video, index) => {
            const videoContainer = this.createVideoElement(video, index);
            videoGrid.appendChild(videoContainer);
        });

        // Apply initial settings
        this.updateLoopStatus();
        this.updateMuteStatus();
    }

    renderNoVideos() {
        const videoGrid = document.getElementById('videoGrid');
        videoGrid.innerHTML = `
            <div class="error">
                üìπ No videos found yet<br>
                <small>Upload videos to your Google Drive folder to get started!</small>
            </div>
        `;
    }

    createVideoElement(video, index) {
        const container = document.createElement('div');
        container.className = 'video-container';
        
        const fileName = video.name || video.path.split('/').pop();
        const displayName = fileName.replace(/\.[^/.]+$/, "").replace(/[-_]/g, ' ');
        
        container.innerHTML = `
            <h3>${displayName}</h3>
            <video 
                id="video-${index}"
                controls 
                preload="metadata"
                ${this.isLoopEnabled ? 'loop' : ''}
                ${this.isMuted ? 'muted' : ''}
                poster=""
            >
                <source src="${video.path}" type="video/mp4">
                Your browser does not support the video tag.
            </video>
            <div class="video-info">
                <div class="video-details">
                    <div>üìÅ ${fileName}</div>
                    ${video.size ? `<div>üìä ${this.formatFileSize(video.size)}</div>` : ''}
                    ${video.lastModified ? `<div>üìÖ ${new Date(video.lastModified).toLocaleDateString()}</div>` : ''}
                </div>
                <a href="${video.path}" download="${fileName}" class="download-btn">
                    ‚¨áÔ∏è Download
                </a>
            </div>
        `;

        // Add video event listeners
        const videoElement = container.querySelector('video');
        this.addVideoEventListeners(videoElement, index);

        return container;
    }

    addVideoEventListeners(videoElement, index) {
        videoElement.addEventListener('loadedmetadata', () => {
            const duration = this.formatDuration(videoElement.duration);
            const detailsDiv = videoElement.parentElement.querySelector('.video-details');
            if (!detailsDiv.querySelector('.duration')) {
                const durationDiv = document.createElement('div');
                durationDiv.className = 'duration';
                durationDiv.textContent = `‚è±Ô∏è ${duration}`;
                detailsDiv.appendChild(durationDiv);
            }
        });

        videoElement.addEventListener('error', (e) => {
            console.error(`Error loading video ${index}:`, e);
            videoElement.parentElement.innerHTML = `
                <div class="error">
                    ‚ùå Error loading video: ${videoElement.src.split('/').pop()}
                </div>
            `;
        });

        // Intersection Observer for lazy loading
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    videoElement.preload = 'auto';
                    observer.unobserve(videoElement);
                }
            });
        });
        observer.observe(videoElement);
    }

    playAllVideos() {
        document.querySelectorAll('video').forEach(video => {
            video.play().catch(e => console.log('Cannot autoplay video:', e));
        });
    }

    pauseAllVideos() {
        document.querySelectorAll('video').forEach(video => {
            video.pause();
        });
    }

    toggleLoop() {
        this.isLoopEnabled = !this.isLoopEnabled;
        this.updateLoopStatus();
        
        const button = document.getElementById('toggleLoop');
        button.textContent = this.isLoopEnabled ? 'üîÑ Loop: ON' : 'üîÑ Loop: OFF';
    }

    updateLoopStatus() {
        document.querySelectorAll('video').forEach(video => {
            video.loop = this.isLoopEnabled;
        });
    }

    toggleMute() {
        this.isMuted = !this.isMuted;
        this.updateMuteStatus();
        
        const button = document.getElementById('toggleMute');
        button.textContent = this.isMuted ? 'üîá Muted' : 'üîä Unmuted';
    }

    updateMuteStatus() {
        document.querySelectorAll('video').forEach(video => {
            video.muted = this.isMuted;
        });
    }

    formatFileSize(bytes) {
        if (bytes === 0 || bytes === 'Unknown') return 'Unknown size';
        
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    formatDuration(seconds) {
        const hrs = Math.floor(seconds / 3600);
        const mins = Math.floor((seconds % 3600) / 60);
        const secs = Math.floor(seconds % 60);
        
        if (hrs > 0) {
            return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    // Method to refresh video list (called after sync)
    async refresh() {
        await this.loadVideos();
    }
}

// Initialize the video gallery when the page loads
document.addEventListener('DOMContentLoaded', () => {
    window.videoGallery = new VideoGallery();
});

// Add keyboard shortcuts
document.addEventListener('keydown', (e) => {
    if (e.target.tagName.toLowerCase() !== 'input' && e.target.tagName.toLowerCase() !== 'textarea') {
        switch(e.key.toLowerCase()) {
            case ' ':
                e.preventDefault();
                // Space bar toggles play/pause for all videos
                const videos = document.querySelectorAll('video');
                const anyPlaying = Array.from(videos).some(v => !v.paused);
                if (anyPlaying) {
                    window.videoGallery.pauseAllVideos();
                } else {
                    window.videoGallery.playAllVideos();
                }
                break;
            case 'l':
                window.videoGallery.toggleLoop();
                break;
            case 'm':
                window.videoGallery.toggleMute();
                break;
            case 'r':
                window.videoGallery.refresh();
                break;
        }
    }
});

// Auto-refresh every 5 minutes to check for new videos
setInterval(() => {
    if (window.videoGallery) {
        window.videoGallery.refresh();
    }
}, 5 * 60 * 1000); 